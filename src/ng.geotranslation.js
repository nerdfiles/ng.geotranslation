// Generated by CoffeeScript 1.7.1
(function() {
  (function(window, angular) {
    'use strict';
    return angular.module('ngGeotranslation', ['ng']).constant('ngGeotranslation.RADIUS', 6371).constant('ngGeotranslation.cachedDeg2Rad', Math.PI / 180).constant('ngGeotranslation.cachedRad2Deg', 180 / Math.PI).service('$$geotranslate', [
      'ngGeotranslation.RADIUS', 'ngGeotranslation.cachedDeg2Rad', 'ngGeotranslation.cachedRad2Deg', function(RADIUS, cachedDeg2Rad, cachedRad2Deg) {
        var serviceInterface;
        serviceInterface = {};
        serviceInterface.toRad = function(angle) {
          return angle * cachedDeg2Rad;
        };
        serviceInterface.toDeg = function(angle) {
          return angle * cachedRad2Deg;
        };
        serviceInterface.bearingTo = function(latitudeStart, longitudeStart, latitudeEnd, longitudeEnd) {
          var distanceLongitude, initialBearing, x, y;
          distanceLongitude = this.toRad(longitudeEnd - longitudeStart);
          x = null;
          y = null;
          initialBearing = null;
          latitudeStart = this.toRad(latitudeStart);
          latitudeEnd = this.toRad(latitudeEnd);
          y = Math.sin(distanceLongitude) * Math.cos(latitudeEnd);
          x = Math.cos(latitudeStart) * Math.sin(latitudeEnd) - Math.sin(latitudeStart) * Math.cos(latitudeEnd) * Math.cos(distanceLongitude);
          initialBearing = this.toDeg(Math.atan2(y, x));
          if (initialBearing < 0) {
            initialBearing += 360;
          }
          return initialBearing;
        };
        serviceInterface.bearingFrom = function(latitudeStart, longitudeStart, latitudeEnd, longitudeEnd) {
          var finalBearing;
          finalBearing = this.bearingTo(latitudeStart, longitudeStart, latitudeEnd, longitudeEnd);
          finalBearing += 180;
          if (finalBearing > 360) {
            finalBearing -= 360;
          }
          return finalBearing;
        };
        serviceInterface.spherical = function(latitudeStart, longitudeStart, latitudeEnd, longitudeEnd) {
          var distance, l1, l2, l3;
          l1 = this.toRad(latitudeStart);
          l2 = this.toRad(latitudeEnd);
          l3 = this.toRad(longitudeEnd - longitudeStart);
          return distance = Math.acos(Math.sin(l1) * Math.sin(l2) + Math.cos(l1) * Math.cos(l2) * Math.cos(l3)) * RADIUS;
        };
        serviceInterface.equirectangular = function(latitudeStart, longitudeStart, latitudeEnd, longitudeEnd) {
          var distance, x, y;
          x = (longitudeEnd - longitudeStart) * Math.cos((latitudeStart + latitudeEnd) / 2);
          y = latitudeEnd - latitudeStart;
          return distance = Math.sqrt(x * x + y * y) * RADIUS;
        };
        serviceInterface.haversine = function(latitudeStart, longitudeStart, latitudeEnd, longitudeEnd) {
          var a, c, distance, distanceLatitude, distanceLongitude;
          distanceLatitude = this.toRad(latitudeEnd - latitudeStart);
          distanceLongitude = this.toRad(longitudeEnd - longitudeStart);
          a;
          c;
          distance;
          latitudeStart = this.toRad(latitudeStart);
          latitudeEnd = this.toRad(latitudeEnd);
          a = Math.sin(distanceLatitude / 2) * Math.sin(distanceLatitude / 2) + Math.sin(distanceLongitude / 2) * Math.cos(latitudeStart) * Math.cos(latitudeEnd);
          c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
          return distance = RADIUS * c;
        };
        return serviceInterface;
      }
    ]);
  })(window, window.angular);

}).call(this);
